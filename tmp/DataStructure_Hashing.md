---
title: Hashing
date: 2019/04/30
categories: DataStructure
---

## 定义

散列表的实现常常叫做散列，散列是一种用于以常数平均时间执行插入、删除和查询的技术。**

每个关键字被映射到从0到TableSize-1这个范围中的某一个值，这个映射叫做散列函数，理想情况是计算简单，不同的关键字映射到不同的单元，但因为关键字是无穷的而单元是有穷的，因此相对完美的散列函数需要做到在单元之间均匀分配关键字。

## 散列函数

如果关键字为整数，那么一般使用Key mod TableSize比较合理，对这个TableSize来说，好的办法是保证它为素数，不容易被整除，分配也很均匀。



如果关键字为字符串，一种办法是将每个字符的ACSII码都加起来得到一个整数，并用整数和TableSize取余。

```java
public static int hash(String key, int tableSize) {
    int hashVal = 0;
    for (int i = 0; i < key.length(); i++) {
        hashVal += key.charAt(i);
    }
    return hashVal % tableSize;
}
```

假设表为10007，key最多八个字符，那么key取值一定在0 ~ 8 * 128之间，这就不是一个均匀的分配。为了扩大取值可以对`hashVal`进行多项式计算:

```java
public static int hash(String key, int tableSize) {
    int hashVal = 0;
    for (int i = 0; i < key.length(); i++) {
        hashVal += 37 * hashVal + key.charAt(i);
    }
    hashVal %= tableSize;
    if (hashVal < 0)
        hashVal += tableSize;
    return hashVal;
}
```

因此对于一个散列来说最重要的两件事，一是找到一个分配均匀计算简单快速的散列函数，二是碰到冲突如何处理。

## 分离链接法

分离链接法的做法是将散列到同一个值得所有元素都保留到一个链表中。如果插入的元素是新元素，那么将存放在链表的前段，因为新插入的元素经常不久又被访问。

这里假设散列函数为key mod 10，81和1对10取余都是1，因此用链表存放在下标为1的单元中。

```
index
  0 -------   -> 0
  1 -------   -> 81 -> 1
  2 -------   -> 
  3 -------   -> 33 -> 3
  4 -------   -> 
  5 -------   -> 
  6 -------   ->      
  7 -------   -> 57 -> 7
  8 -------   -> 
  9 -------   -> 
```

实现分离链接法需要的是数组加链表。因此他的构造方法首先要实例化所有的链表：

```java
LinkedList lists[];
private SeperateChainingHashTable(int tableSize) {
    lists = new LinkedList[tableSize];
    for (LinkedList list : lists) {
        list = new LinkedList();
    }
}
```

对于插入操作，首先通过散列函数得到数组的下标，利用下标得到对应的链表，之后就是遍历是否有该元素，没有的话就add，对于remove和contain来说也是一样的。

```java
public void insert(int x) {
    int index = mySimpleHash(x);
    List whichList = lists[index];
    if (!whichList.contains(x)) {
        whichList.add(x);
    }
}
```

## 探测散列表

分离链接法的缺点是使用了两种数据结构来维护，这就导致算法速度减慢，另一种解决冲突的办法就是不用链表，而是尝试别的单元，直到找到一个空的单元为止，也就是一个坑一个萝卜。而用分离链接法就是一个坑一串萝卜。而这样的表叫做探测散列表，一般来说探测散列表的TableSize要比分离链接法的大，并且装填因此要小于0.5。

### 线性探测法

我们把函数f叫做线性冲突方法，线性探测法就表示函数f是i的线性函数。假设f(i)=i，入参i表示平移的单位量。

|      | After 89 | After 18 | After 49 | After 58 |
| :--: | :------: | :------: | :------: | :------: |
|  0   |          |          |    49    |    49    |
|  1   |          |          |          |    58    |
|  2   |          |          |          |          |
|  3   |          |          |          |          |
|  4   |          |          |          |          |
|  5   |          |          |          |          |
|  6   |          |          |          |          |
|  7   |          |          |          |          |
|  8   |          |    18    |    18    |    18    |
|  9   |    89    |    89    |    89    |    89    |

当插入49时，49与89发生冲突，则放入下一个空闲地址0，而58和18发生冲突，继续向下找，地址9和0分别被89和49占用了，因此只能放在地址1上。

因此这种方式只要表足够大，一定能找到个空的单元，但是这样花费时间很久并且容易生成一些区块，称为一次聚集，换句话说每次插入数据都需要试选这些单元。

### 平方探测法

和线性探测法类似，只不过把冲突函数改成了f(i)=i^2。平方探测法是为了消除线性探测法产生的一次聚集问题。

|      | After 89 | After 18 | After 49 | After 58 |
| ---- | -------- | -------- | -------- | -------- |
| 0    |          |          | 49       | 49       |
| 1    |          |          |          |          |
| 2    |          |          |          | 58       |
| 3    |          |          |          |          |
| 4    |          |          |          |          |
| 5    |          |          |          |          |
| 6    |          |          |          |          |
| 7    |          |          |          |          |
| 8    |          | 18       | 18       | 18       |
| 9    | 89       | 89       | 89       | 89       |

插入49时，与89发生冲突，则继续试探一个单元，发现地址0是空的，因此平移1^2个单元，插入58的时候，由于与18发生冲突，继续探测了地址9和地址0才找到空的单元，因此从地址8开始平移2^2个单元，也就是对应到了地址2。

### 具体实现

